# 良いコード／悪いコードで学ぶ設計入門
Amazon Link：www.amazon.co.jp/dp/B09Y1MWK9N

## 第１章　悪しき構造の弊害を知覚する
設計が重要。設計をないがしろにするとさまざまな弊害が発生する

- コードを読み解くのに時間がかかる
- バグを埋め込みやすくなる
- 悪しき構造がさらに悪しき構造を誘発する

悪い例

- 意味不明な命名
    - 技術駆動な命名
    - 連番命名
- 理解を困難にする条件分岐のネスト
    - 何重にもネストしたロジック
- データを保持するだけのデータクラス
    - 別クラスで計算ロジックをもつことがしばしば
        - 例えば、消費税関係の仕様変更が生じた際に変更漏れが発生しやすくなる
            - 税込計算ロジックが共通化されていないことが原因で発生

## 第２章　設計の初歩
設計⇒ここではクラス設計を指す

- 省略せずに意図が伝わる名前を設計する
- 変数を使いまわさない、目的ごとの変数を用意する
    - 再代入するのではなく、新たに変数を用意すること
- ベタ書きせず、意味のあるまとまりでメソッド化
- 関係し合うデータとロジックをクラスにまとめる

## 第３章　クラス設計　ーすべてにつながる設計の基盤ー
保守や変更がしやすいコードを書くには、関心の分離が重要

- 頑強なクラスの構成要素
    - インスタンス変数（フィールド）
    - メソッド→インスタンス変数を不正状態から防御し、正常に操作するメソッド
- メソッドは必ずインスタンス変数を使用すること
- すべてのクラスは単体で使えるものになっていること
    - 別のクラスに初期化してもらったり、データの入力をチェックしてもらったりしているようなクラスは、単体で安全に利用できない未熟なクラス
- コンストラクタで確実に正常値を設定する
    - 必ずコンストラクタで初期化する
    - コンストラクタにガード節を組み込んで、正常値のみが確実に設定されるようにする
- 計算ロジックをデータ保持側に寄せる
    - 例えば、Moneyクラスにadd()という金額加算メソッドを用意する
- インスタンス変数を不変（イミュータブル）にする
    - 変数の値が変わる前提だと、いつ変更されたのか、今の値がどうなっているのかをいちいち気にしなければならない。
    - finalで不変にする→一度しか代入できなくなる
- 変更したい場合は新しいインスタンスを作成する
    - 変更値を持ったクラスのインスタンスを生成すればよい
        - 例：int added
- メソッド引数やローカル変数にもfinalを付け不変にする
- 「値の渡し間違い」を型で防止する
    - プリミティブ型（int, String）に拘らず、Money型など自作の型を用いるとミスが減る
- 現実の営みにはないメソッドを追加しないこと
    - 加算のメソッドを用意したので、善意で乗算、除算などを用意しないこと
- プログラム構造の問題解決に役立つ設計パターン
    - 完全コンストラクタ
        - 不正状態から防護する
    - 値オブジェクト
        - 特定の値に関するロジックを高凝集にする
        - 値の概念そのものをクラスとして定義する→例：Money型
    - ストラテジ
        - 条件分岐を削減し、ロジックを単純化する
    - ポリシー
        - 条件分岐を単純化したり、カスタマイズできるようにする
    - ファーストクラスコレクション
        - 値オブジェクトの亜種で、コレクションに関するロジックを高凝集にする
    - スプラウトクラス
        - 既存のロジックを変更せずに安全に新機能を追加する
- 値オブジェクト＋完全コンストラクタはオブジェクト指向設計の最も基本形を体現している構造のひとつ

## 第４章　不変の活用　ー安定動作を構築するー
再代入はさけるべき

- 不変にして再代入を防ぐ
    - final修飾子をつける
- メソッドの引数も不変にする

可変がもたらす意図しない影響

- ケース１：可変インスタンスの使い回し
    - インスタンスを使い回していると、あるインスタンスを変更したら他方のインスタンスの値も変更されたという問題が発生しうる
- ケース２：関数による可変インスタンスの操作

副作用のデメリット

副作用⇒関数が引数を受け取り、戻り値を返す以外に、外部の状態（変数など）を変更すること

- インスタンス変数の変更
- グローバル変数の変更
- 引数の変更
- ファイルの読み書きなどのI/O操作

関数の影響範囲を限定する

- データ、つまり状態を引数で受け取る
- 状態を変更しない
- 値は関数の戻り値として返す

副作用のない関数を厳密に作り込むよりも、クラスのスコープ内で影響を閉じ込めるスタイルが一般的

不変にする

値を更新する場合は値オブジェクトのインスタンスを新規で生成する

## 第５章　低凝集　ーバラバラになったモノたちー
低凝集=データとロジックがちらばってるコードは壊れやすく、変更が困難で望ましくない

低凝集の代表例としてはデータクラスがある

- staticメソッドの誤用
    - staticメソッドを使用する時点で、データとデータを操作するロジックが乖離する。どうしても低凝集にならざるをえない。
    - インスタンス変数を使う構造につくり変える
    - 凝集度に影響がない場合にstaticメソッドは使用すること。例えば、ファクトリメソッドとしてstaticメソッドを使用する。
- 初期化ロジックの分散
    - コンストラクタを公開すると、さまざまな用途につかわれがち。引数がさまざまなものが使われる。変更したいときに全ソースをチェックしなければならない。
    - privateコンストラクタ+ファクトリメソッドで目的別初期化
        - コンストラクタをprivateにして、代わりに目的別のファクトリメソッドを用意する
    - 生成ロジックが増えすぎたらファクトリクラスを検討すること
- 共通クラス（Common・Util）
    - 共通処理用のメソッドはstaticメソッドとして実装されがち。
        - 例えば、消費税計算
    - さまざまな処理が雑多に置かれがち
    - 共通処理クラスを安易に作らないようにする。
        - 横断的関心事であればつくる
            - ログ出力
            - エラー検出
            - デバッグ
            - 例外処理
            - キャッシュ
            - 同期処理
            - 分散処理
    - 結果を返すために引数を使わないこと
- 引数が多すぎるメソッド
    - 意味のある単位ごろにクラス化する
        - プリミティブ型に執着せず、新たにクラス定義すること
    - 詳細なロジックは呼ぶ側ではなく、呼ばれる側に実装する

## 第６章　条件分岐　ー迷宮化した分岐処理を解きほぐす技法ー
条件分岐のネストによる可読性低下

- 早期returnでネスト解消
    - 条件ロジックと実行ロジックを分離できるメリットもある
- 見通しを悪くするelse句も早期returnで解決
- switch文の重複をさける
    - 条件分岐を１箇所にまとめる
        - switch文が悪いのではなく、同様のswitch文が複数存在すると、修正漏れが発生しやすくなることが悪い。これにより、switch文を使わない方法を検討する必要がでてくる。
    - スマートにswitch文重複を解消するにはinterfaceを使う
        - 例：同じShape interfaceをRectangeクラスとCircleクラスの双方で実装すると、型の判定をする必要がなくなる
        - switchの代わりにMapで切り替える
        
        →**ストラテジパターン**を使っている
        
- 条件分岐の重複とネスト
    - ここでもinterfaceを使うとよい
        - ポリシーパターンで条件を集約する
            - 条件の部品化、部品化した条件を組み替えてのカスタマイズを可能にする
- 型チェックで分岐しないこと
    - interfaceを使っても条件分岐が減らない、よくないやり方がある
        - instanceofとかでわざわざ型チェックするのはNG→リスコフの置換原則に違反
    - interfaceで切り替えられるようにするべき
- interfaceの使いこなしが中級者への第一歩
    - **分岐：迷わずif文やswitch文を使う→interface設計を試みる**
    - **分岐ごとの処理：ロジックをベタ書きする→クラス化を試みる**
- フラグ引数
    - メソッドの機能を切り替えるboolean型引数をフラグ引数と呼ぶ
        - 何が起こるか読み手に想像を難しくさせる問題がある
        - int型でも、条件によって機能を切り替えていたら同様
    - メソッドを分離する
        - フラグ引数付きメソッドは内部に複数の機能をもち、フラグで切り替えている構造
            - 機能ごとにメソッドを作成する
        - 切り替え機構をストラテジパターンで実現する
            - 例：<<interface>> Damageを複数実装→HitPointDamage, MagicPointDamage
            - enumとMapで処理を切り替える
                - 処理のタイプをenumで定義する
                - Mapにタイプと内容を登録
                - 処理を呼び出す

## 第７章　コレクション　ーネストを解消する構造化技法ー
例：所持品の中に「牢屋の鍵」があるかを調べるコード→forループの中にif文をかく

→anyMatchでスッキリ１行でかけるのに、わざわざ複雑なロジックを書かない

- ループ処理中の条件分岐ネスト
    - 早期continueで条件分岐のネストを解消する
    - 早期breakもネスト解消に役立つ
- 低凝集なコレクション処理
    - コレクション処理をカプセル化する
        - ファーストクラスコレクション
            - コレクション型のインスタンス変数
            - コレクション型のインスタンス変数を不正状態から防御し、正常に操作するメソッド
            
            →同じクラスにインスタンス変数とメソッドを作成する
            
        - 外部へ渡す場合はコレクションを変更できなくする
            - unmodifiableListにしてからreturn

## 第８章　密結合　ー絡まって解きほぐせない構造ー
結合度とは、「モジュール（クラス）間の、依存の度合いを表す指標」

密結合の問題を解決する上で、責務の考えは重要

- 密結合と責務
    - 単一責任の原則
        - 責務が単一になるようにクラスを設計する
    - DRY原則の誤用
        - 「コードの重複を許すな」というわけではない。同じようなロジックでも概念（責務）が違えばDRYにすべきではない。
- 密結合の各種事例と対処方法
    - スーパークラス依存
        - 継承はかなり注意しないと密結合に陥りやすい
        - サブクラスはスーパークラスの構造をいちいち気にする必要がある
        - 継承より委譲を用いる
            - privateなインスタンスヘンスとして持ち、呼び出す
    - インスタンス変数ごとにクラス分割可能なロジック
        - それぞれのクラスを作成して分離してしまう
    - なんでもpublicで密結合
        - 関係ないクラスが結びつき、影響範囲が拡大する。結果メンテナンスが困難な構造になる。
    - privateメソッドだらけ
    - 高凝集の誤解から来る密結合
    - スマートUI
        - 表示関連のクラスの中に、表示以外の責務のロジックが実装されている構造のこと。
    - 巨大なデータクラス
    - トランザクションスクリプトパターン
    - 神クラス
    - 密結合クラスの対処法

## 